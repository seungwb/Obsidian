---
tags:
  - SpringBasic
---
---

## 다양한 의존관계 주입 방법

---

>의존관계 주입 방법으로는 크게 4가지 방법이 있다.
- 생성자 주입
- `setter` 주입
- 필드 주입
- 일반 매서드 주입

### 생성자 주입

- 생성자를 통해 의존 관계를 주입하는 방법
- 생성자 호출시점에 1번 호출 보장
- **불변, 필수** 의존 관계에 사용

```java
@Component  
public class OrderServiceImpl implements OrderService{  
  
    private final MemberRepository memberRepository;  
    private final DiscountPolicy discountPolicy;  
  
    @Autowired  
    public OrderServiceImpl(MemberRepository memberRepository
						    , DiscountPolicy discountPolicy) {  
        this.memberRepository = memberRepository;  
        this.discountPolicy = discountPolicy;  
    }  
}
```

- 생성자가 1개만 있으면 `@Autowired` 생략이 가능하다.

### `setter` 주입

- `setter`로 필드의 값을 변경하는 것을 통해 의존관계를 주입하는 방법
- **선택, 변경** 가능성이 있는 의존관계에 사용
- 자바빈 프로퍼티 규약의 수정자 메서드 방식 사용

```java
@Component  
public class OrderServiceImpl implements OrderService{  
  
    private MemberRepository memberRepository;  
    private DiscountPolicy discountPolicy;  
  
    @Autowired
    public void setDiscountPolicy(DiscountPolicy discountPolicy) {
	    this.discountPolicy = discountPolicy;
    }
	@Autowired
    public void setMemberRepository(MemberRepository memberRepository) {
	    this.memberRepository = memberRepository;
    }
}
```

### 필드 주입

- 필드에 바로 주입하는 방식
- 코드가 간결해지는 장점이 있다.
- 하지만 외부 변경이 불가하여 테스트 하기 힘들다는 단점이 있다.
- 테스트 코드정도에서만 사용하여야 한다.

```java
@Component  
public class OrderServiceImpl implements OrderService{  

	@Autowired
    private MemberRepository memberRepository;  
    
    @Autowired
    private DiscountPolicy discountPolicy;  

}
```

### 일반 메서드 주입

- 일반 메서드를 통해 주입 받는 방법이다.
- 한번에 여러 필드를 주입 받을 수 있다.
- 일반적으로는 잘 사용하지 않는다.

```java
@Component  
public class OrderServiceImpl implements OrderService{  
  
    private MemberRepository memberRepository;  
    private DiscountPolicy discountPolicy;  
  
    @Autowired  
    public init(MemberRepository memberRepository
						    , DiscountPolicy discountPolicy) {  
        this.memberRepository = memberRepository;  
        this.discountPolicy = discountPolicy;  
    }  
}
```


## 옵션 처리

---

>주입할 스프링 빈이 없어도 동작해야 하는 경우, 사용할 수 있는 옵션은 다음과 같다.

- `@Autowired(required=false)`: 자동 주입할 대상이 없으면 메서드 자체가 호출 안됨
- `@Nullable`: 자동 주입할 대상이 없으면 null이 들어간다.
- `Optional<>`: 자동 주입할 대상이 없으면 `Optional.empty`가 들어간다.

```java
static class TestBean {  
  
    @Autowired(required = false)  
    public void setNoBean1(Member noBean1){  
        System.out.println("noBean1 = " + noBean1);  
    }  
  
    @Autowired  
    public void setNoBean2(@Nullable Member noBean2){  
        System.out.println("noBean2 = " + noBean2);  
    }  
  
    @Autowired  
    public void setNoBean3(Optional<Member> noBean3){  
        System.out.println("noBean3 = " + noBean3);  
    }  
}
```

## 어떤 방법이 맞을까?

---

>과거에는 `setter` 주입과 필드 주입이 많이 사용됐지만, 최근에는 스프링을 포함한 DI 프레임워크 대부분에서 **생성자 주입을 권장**한다.

### 생성자 주입을 권장하는 이유

#### 불변 보장

- 대부분의 의존관계 주입은 한번 하고나면 애플리케이션 종료시점까지 변경할 일이 없다.
- 변경할 일이 없을뿐더러 절대 변경되어서는 안되는 경우가 대다수다.
- 생성자 주입으로만 필드에 `final`을 사용 할 수 있어 불변을 더욱 보장 할 수 있다.
- 생성자 주입은 객체를 생성할 때 1번만 호출되므로 불변을 보장할 수 있다.

#### 누락 방지

- 순수한 자바코드로 테스트 코드 작성 시 생성자 특성 상 주입 데이터를 입력하지 않으면 컴파일 단계에서 바로 오류를 발생시켜 손쉽게 수정 가능하다.

## Lombok

---

>개발을 하다보면 대부분이 불변이기에 필드에 **final** 키워드를 사용하게 된다. 그럴때마다 반복적인 코드를 만들게 되는데 그것을 최적화 하기 위한 라이브러리로 Lombok을 사용한다.

### 사용 전

```java
@Component  
public class OrderServiceImpl implements OrderService{  
  
    private final MemberRepository memberRepository;  
    private final DiscountPolicy discountPolicy;  
  
    @Autowired  
    public OrderServiceImpl(MemberRepository memberRepository, 
						    DiscountPolicy discountPolicy) {  
        this.memberRepository = memberRepository;  
        this.discountPolicy = discountPolicy;  
    }
}
```

### 사용 후

```java
@Component  
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService{  
  
    private final MemberRepository memberRepository;  
    private final DiscountPolicy discountPolicy;  
}
```

## 같은 타입의 빈 2개 이상 시 해결 방안

---

>같은 타입의 빈을 2개 이상 조회 될때, `NoUniqueBeanDefinitionException` 오류가 발생한다. 이럴 때 해결 가능한 방법이 크게 3가지 있다.

### `@Autowired` 필드명 매칭

```java
@Autowired
private final DiscountPolicy rateDiscountPolicy;
```

- 이런식으로 빈으로 등록되는 객체의 이름을 필드명으로 사용하면 해당 객체를 의존성 주입하게 된다.

### `@Qualifier`

#### 빈 등록 시

```java
@Component
@Qualifier("mainDiscountPolicy")
public class RateDiscountPolicy implements Discountpolicy{
	....
}
```

#### 생성자 자동 주입 시

```java
@Autowired
public OrderServiceImpl(MemberRepository memberRepository, 
	@Qualifier("mainDiscountPolicy") Discountpolicy discountpolicy){
	this.memberRepository = memberRepository;
	this.discountpolicy = discountpolicy;
}
```

- 이런식으로 등록할 빈의 이름을 정해주고 생성자 주입 시 해당 이름을 객체 앞에 붙여주면 된다.

### `@Primary`

```java
@Component
@Primary
public class RateDiscountPolicy implements Discountpolicy{
	....
}
```

- `@Primary`가 붙은 빈을 가장 우선순위로 의존성 주입하게 된다.

### 어떻게 사용해야 할까?

- 주로 사용하는 빈에 `@Primary`를 사용하여 기본적으로 불러오게 하되, 특별히 사용해야 할 일이 있는 곳에 `@Qualifier`를 사용하여 주는것이 좋다.

## 조회한 빈이 모두 필요한 경우

---

```java
public class AllBeanTest {  
    @Test  
    void findAllBean() {  
        ApplicationContext ac = 
					        new AnnotationConfigApplicationContext(
								        AutoAppConfig.class, 
								        DiscountService.class);  
	  
        DiscountService discountService = ac.getBean(DiscountService.class);  
        Member member = new Member(1L, "userA", Grade.VIP);  
        int discountPrice = 
        discountService.discount(member, 10000, "fixDiscountPolicy");  
  
        assertThat(discountService).isInstanceOf(DiscountService.class);  
        assertThat(discountPrice).isEqualTo(1000);  
    }  
  
    @Service  
    static class DiscountService {  
        private final Map<String, DiscountPolicy> policyMap;  
        private final List<DiscountPolicy> policies;  
  
        @Autowired  
        public DiscountService(Map<String, DiscountPolicy> policyMap, List<DiscountPolicy> policies) {  
            this.policyMap = policyMap;  
            this.policies = policies;  
            System.out.println("policyMap = " + policyMap);  
            System.out.println("policies = " + policies);  
        }  
  
        public int discount(Member member, int price, String discountCode) {  
            DiscountPolicy discountPolicy = policyMap.get(discountCode);  
            return discountPolicy.discount(member, price);  
        }  
    }  
}
```